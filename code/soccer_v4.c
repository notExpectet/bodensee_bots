#pragma config(Sensor, S1,     Ult1,           sensorEV3_Ultrasonic)
#pragma config(Sensor,  S2,     Ult2,           sensorEV3_Ultrasonic)
#pragma config(Sensor,  S3,     SeekerPort,     sensorEV3_IRSensor)
#pragma config(Sensor,  S4,     KompassPort,    sensorI2CCustom)
#pragma config(Motor,  motorA,          motorLinks,    tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Dribbler,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRechts,   tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-compass.h"
#include "hitechnic-irseeker-v2.h"

// --- Konstante Parameter ---
#define TURN_SPEED_SLOW        5     // langsame Drehgeschwindigkeit
#define DRIVE_SPEED_FAST_LEFT  30    // Geradeaus links
#define DRIVE_SPEED_FAST_RIGHT 32    // Geradeaus rechts leicht schneller
#define LOOP_DELAY_MS          50    // Zyklusdauer in ms
#define DISPLAY_INTERVAL       10    // Display-Update alle n Zyklen
#define DEADZONE               3     // Toleranz fÃ¼r Tor-Ausrichtung
#define CENTER_IR              5     // IR-Mitte
#define DRIBBLER_RPM_MIN       150   // Untere RPM-Grenze ballbereit
#define DRIBBLER_RPM_MAX       195   // Obere RPM-Grenze ballbereit

// --- Globale Variablen ---
tHTMC Kompass;
tHTIRS2 Seeker;
int TorRichtung;
int Abweichung;
int BallRichtung;

// --- Funktion: Anzeige aktualisieren ---
void UpdateDisplay() {
  eraseDisplay();
  displayBigTextLine(0, "Abw: %d", Abweichung);
  displayBigTextLine(2, "Ball: %d", BallRichtung);
  displayBigTextLine(4, "DribblerRPM: %d", getMotorRPM(Dribbler));
  displayBigTextLine(6, "TorOffset: %d", TorRichtung);
}

// --- Funktion: Ball suchen und ansteuern ---
void BallSuchen() {
  switch (BallRichtung) {
    case CENTER_IR:  // Ball geradeaus
      setMotorSpeed(motorLinks, DRIVE_SPEED_FAST_LEFT);
      setMotorSpeed(motorRechts, DRIVE_SPEED_FAST_LEFT);
      break;
    case CENTER_IR - 1:  // Ball leicht rechts
      setMotorSpeed(motorLinks, -TURN_SPEED_SLOW);
      setMotorSpeed(motorRechts, TURN_SPEED_SLOW);
      break;
    case CENTER_IR + 1:  // Ball leicht links
      setMotorSpeed(motorLinks, TURN_SPEED_SLOW);
      setMotorSpeed(motorRechts, -TURN_SPEED_SLOW);
      break;
    default:
      if (BallRichtung > CENTER_IR) {
        // Ball weiter links
        setMotorSpeed(motorLinks, DRIVE_SPEED_FAST_LEFT);
        setMotorSpeed(motorRechts, -DRIVE_SPEED_FAST_LEFT);
      } else if (BallRichtung > 0 && BallRichtung < CENTER_IR) {
        // Ball weiter rechts
        setMotorSpeed(motorLinks, -DRIVE_SPEED_FAST_LEFT);
        setMotorSpeed(motorRechts, DRIVE_SPEED_FAST_LEFT);
      } else {
        // Kein Signal: anhalten
        setMotorSpeed(motorLinks, 0);
        setMotorSpeed(motorRechts, 0);
      }
      break;
  }
}

// --- Funktion: Tor ausrichten ---
void AusrichtenTor() {
  if (abs(Abweichung) <= DEADZONE) {
    // Geradeaus zum Tor
    setMotorSpeed(motorLinks, DRIVE_SPEED_FAST_LEFT);
    setMotorSpeed(motorRechts, DRIVE_SPEED_FAST_RIGHT);
  } else if (Abweichung < 0) {
    // Rechts Drehung (Tor links)
    setMotorSpeed(motorLinks, TURN_SPEED_SLOW);
    setMotorSpeed(motorRechts, -TURN_SPEED_SLOW);
  } else {
    // Links Drehung (Tor rechts)
    setMotorSpeed(motorLinks, -TURN_SPEED_SLOW);
    setMotorSpeed(motorRechts, TURN_SPEED_SLOW);
  }
}

// --- Hauptprogramm ---
task main() {
  int loopCount = 0;

  // Dribbler starten
  setMotorSpeed(Dribbler, 100);

  // Sensor-Initialisierung
  initSensor(&Kompass, KompassPort);
  readSensor(&Kompass);
  TorRichtung = Kompass.heading;
  Kompass.offset = TorRichtung;

  initSensor(&Seeker, SeekerPort);

  clearTimer(timer1);

  while (true) {
    int cycleStart = time1[timer1];

    // Sensorwerte auslesen
    readSensor(&Kompass);
    Abweichung = Kompass.relativeHeading;
    readSensor(&Seeker);
    BallRichtung = Seeker.acDirection;

    // Ball suchen
    BallSuchen();

    // Tor-Ausrichtung nur wenn Ball dribbelbereit
    int dribblerRPM = getMotorRPM(Dribbler);
    if (dribblerRPM >= DRIBBLER_RPM_MIN && dribblerRPM <= DRIBBLER_RPM_MAX) {
      AusrichtenTor();
    }

    // Display-Update drosseln
    if (loopCount % DISPLAY_INTERVAL == 0) {
      UpdateDisplay();
    }

    // Zyklus-Timing sichern
    int elapsed = time1[timer1] - cycleStart;
    if (elapsed < LOOP_DELAY_MS) {
      wait1Msec(LOOP_DELAY_MS - elapsed);
    }
    clearTimer(timer1);
    loopCount++;
  }
}
