#pragma config(Sensor, S1,     Ult1,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     Ult2,           sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          motorLinks,    tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Dribbler,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRechts,   tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	This code is intellectual property of Bodensee Bots j.r.t. and is not allowed to be used for commercial purposes.
	The authors are not responsible for any damage caused by the use of this code.
	Code created by:  Peer Siems, 2025 / Marlon Jost, 2025
	Soccerversion 8x (under construction) test
*/

#include "hitechnic-compass.h"
#include "hitechnic-irseeker-v2.h"

#define SeekerPort S3
#define KompassPort S4

tHTMC Kompass;
tHTIRS2 Seeker;

int status = 0;
// Status: 0 = idle, 1 = suche ball, 2 = habe Ball,

// Variablen definieren
int BallRichtung;
int dribbler_speed_ini; // Ursprüngliche Dribbler Geschwindigkeit
int dribbler_speed; // Dribbler Geschwindigkeit
int me_dir; // Roboter Richtung
int ball_dir; // Ball Richtung
int dir_diff;
int ini_goal_dir; // Torwamnd Richtung
int toleranz = 10;
int motor_speed = 25;
float goal_dir; // Tor Richtung
float dis_r; // Ultraschall Entfernung Rechts
float dis_h; // Ultraschall Entfernung Links

//---------------------------------------------------------------------------
//  alignToHeadingStep()
//    • targetHeading : gewünschter Winkel 0-359°
//    • driveForward  : false = Drehung auf der Stelle
//                      true  = während des Drehens mit motor_speed vorwärts
//    • tol           : Winkel-Toleranz
//
//  Rückgabe: true  ? Ziel erreicht (innerhalb tol)
//            false ? weiter ausrichten
//
//  Die Funktion prüft KEINEN Ballbesitz – das erledigt dein Hauptcode.
//---------------------------------------------------------------------------
bool alignToHeadingStep(int targetHeading, bool driveForward = false, int tol = toleranz)
{
    const int maxTurnSpeed = 60;   // maximale Drehgeschwindigkeit
    const int minTurnSpeed = 10;   // minimale Drehgeschwindigkeit

    //------------------------ Kursregler (ein Schritt) ---------------------
    readSensor(&Kompass);
    int curr = Kompass.relativeHeading;          // 0-359°

    // kürzesten Winkelfehler -180 … +180 berechnen
    int diff = targetHeading - curr;
    if (diff > 180)  diff -= 360;
    if (diff < -180) diff += 360;

    int absDiff = abs(diff);
    if (absDiff <= tol) {                        // Ziel erreicht
        if (driveForward) {
            setMotorSpeed(motorLinks,  motor_speed);
            setMotorSpeed(motorRechts, motor_speed);
        } else {
            setMotorSpeed(motorLinks,  0);
            setMotorSpeed(motorRechts, 0);
        }
        return true;
    }

    // proportionale Drehgeschwindigkeit
    int turn = (absDiff * maxTurnSpeed) / 180;
    if (turn < minTurnSpeed) turn = minTurnSpeed;
    if (turn > maxTurnSpeed) turn = maxTurnSpeed;

    if (!driveForward) {
        // Rotation auf der Stelle
        setMotorSpeed(motorLinks,  (diff > 0) ?  turn : -turn);
        setMotorSpeed(motorRechts, (diff > 0) ? -turn :  turn);
    } else {
        // Vorwärts + Differenzial-Lenkung
        int left  =  motor_speed + ((diff > 0) ?  turn : -turn);
        int right =  motor_speed - ((diff > 0) ?  turn : -turn);

        // Begrenzen auf -100 … +100
        left  = (left  > 100) ? 100 : (left  < -100 ? -100 : left);
        right = (right > 100) ? 100 : (right < -100 ? -100 : right);

        setMotorSpeed(motorLinks,  left);
        setMotorSpeed(motorRechts, right);
    }
    return false;                                 // noch nicht im Ziel
}



void rotate_to_dir(int tar_dir, bool drive_forward)
{

}

// Main Task
task main();
{
	setMotorSpeed(Dribbler, 100); // Ürsprünglicher Dribbler Speed
	dribbler_speed_ini = getMotorRPM(Dribbler); // Ursprünglicher Dribbler Speed festlegen

	initSensor (&Kompass, KompassPort);
	readSensor (&Kompass);
	ini_goal_dir = Kompass.heading;
	Kompass.offset = goal_dir;

	while (true)
	{
		// Sensoren Auslesen
		readSensor(&Kompass);
		me_dir = Kompass.relativeHeading;

		readSensor (&Seeker);
		ball_dir = Seeker.acDirection;

		dribbler_speed = getMotorRPM(Dribbler);

		dis_h = getUSDistance(Ult1);
		dis_r = getUSDistance(Ult2);

		BallRichtung = ball_dir;
		// Main


		if ((dribbler_speed < dribbler_speed_ini + toleranz) && (dribbler_speed > dribbler_speed_ini - toleranz))
		{
			status = 2; // habe Ball

			if (me_dir == ini_goal_dir)
			{
				dis_h;
				dis_r;
				//hier Peer's Rechnung für Torwinkel einfügen
				if (alignToHeadingStep == false)
				{
					alignToHeadingStep(goal_dir, false);
				}





			}
			else
			{
				alignToHeadingStep(ini_goal_dir, true);

			}
			// werte nehmen
			// Tor Berechnen
			// auf Tor korregierenw
			// ins tor fahren
		}
		else
		{
			status = 1; // suche Ball

			// Ball suchen
			if (BallRichtung == 5)
			{
				setMotorSpeed(motorLinks, motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
			else if (BallRichtung < 5) // Ball rechts
			{
				setMotorSpeed(motorLinks, -motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
			else if (BallRichtung > 5) // Ball links
			{
				setMotorSpeed(motorLinks, motor_speed);
				setMotorSpeed(motorRechts, -motor_speed);
			}
			else
			{
				setMotorSpeed(motorLinks, -motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
		}
		wait1Msec (50);
	}

}
