#pragma config(Sensor, S1,		 UltLinks,			 sensorEV3_Ultrasonic) // linker Ultraschallsensor
#pragma config(Sensor, S2,		 UltFront,			 sensorEV3_Ultrasonic) // vorderer Ultraschallsensor
#pragma config(Motor,	 motorA,					motorLinks,		 tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,	 motorB,					Dribbler,			 tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,	 motorD,					motorRechts,	 tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*
This code is intellectual property of Bodensee Bots j.r.t. and is not allowed to be used for commercial purposes.
The authors are not responsible for any damage caused by the use of this code.
Code created by:	Peer Siems, 2025 / Marlon Jost, 2025
Soccerversion 8x (under construction) BETA RELEASE
*/

#include "hitechnic-compass.h"
#include "hitechnic-irseeker-v2.h"

#define SeekerPort S3
#define KompassPort S4

tHTMC Kompass;
tHTIRS2 Seeker;

// Spielfeldabmessungen in Zentimetern
#define FIELD_LENGTH 180
#define FIELD_WIDTH  120

int status = 0;
// Status: 0 = idle, 1 = suche ball, 2 = habe Ball

// Variablen definieren
int dribbler_speed_ini; // Ursprüngliche Dribbler Geschwindigkeit
int dribbler_speed; // Dribbler Geschwindigkeit
int me_dir; // Roboter Richtung
int ball_dir; // Ball Richtung
int dir_diff;
int ini_goal_dir; // Torwand Richtung
int toleranz = 20;
int motor_speed = 25;
int turn_speed = 0;
bool goal_final;
bool have_ball;
float goal_dir; // Tor Richtung
float dis_front; // Ultraschall Entfernung vorne
float dis_left;	 // Ultraschall Entfernung links



void debugScreen()
{
	eraseDisplay();
	displayBigTextLine(0, "Dir:%3d", me_dir);
	displayBigTextLine(2, "Ball:%3d", ball_dir);
	displayBigTextLine(4, "UL:%3.0f UF:%3.0f", dis_left, dis_front);
	displayBigTextLine(6, "Goal:%3.0f", goal_dir);
	displayBigTextLine(8, "Habe Ball?:%d", have_ball);
	displayBigTextLine(10, "ds:%d",dribbler_speed)
}





//---------------------------------------------------------------------------
//	alignToHeadingStep()
//		? targetHeading : gewünschter Winkel 0-359°
//		? driveForward	: false = Drehung auf der Stelle
//											true	= während des Drehens mit motor_speed vorwärts
//		? tol						: Winkel-Toleranz
//
//	Rückgabe: true	? Ziel erreicht (innerhalb tol)
//						false ? weiter ausrichten
//
//	Die Funktion prüft KEINEN Ballbesitz ? das erledigt dein Hauptcode.
//---------------------------------------------------------------------------
bool alignToHeadingStep(int targetHeading, bool driveForward = false, int tol = toleranz)
{
	const int maxTurnSpeed = 60;	 // maximale Drehgeschwindigkeit
	const int minTurnSpeed = 10;	 // minimale Drehgeschwindigkeit

	//------------------------ Kursregler (ein Schritt) ---------------------
	readSensor(&Kompass);
	int curr = Kompass.relativeHeading;					 // 0-359°

	// kürzesten Winkelfehler -180 ? +180 berechnen
	int diff = targetHeading - curr;
	if (diff > 180)	 diff -= 360;
	if (diff < -180) diff += 360;

	int absDiff = abs(diff);
	if (absDiff <= tol) {												 // Ziel erreicht
		if (driveForward) {
			setMotorSpeed(motorLinks,	 motor_speed);
			setMotorSpeed(motorRechts, motor_speed);
			} else {
			setMotorSpeed(motorLinks,	 0);
			setMotorSpeed(motorRechts, 0);
		}
		return true;
	}

	// proportionale Drehgeschwindigkeit
	int turn = (absDiff * maxTurnSpeed) / 180;
	if (turn < minTurnSpeed) turn = minTurnSpeed;
	if (turn > maxTurnSpeed) turn = maxTurnSpeed;

	if (!driveForward) {
		// Rotation auf der Stelle
		setMotorSpeed(motorLinks,	 (diff > 0) ?	 turn : -turn);
		setMotorSpeed(motorRechts, (diff > 0) ? -turn :	 turn);
		} else {
		// Vorwärts + Differenzial-Lenkung
		int left	=	 motor_speed + ((diff > 0) ?	turn : -turn);
		int right =	 motor_speed - ((diff > 0) ?	turn : -turn);

		// Begrenzen auf -100 ? +100
		left	= (left	 > 100) ? 100 : (left	 < -100 ? -100 : left);
		right = (right > 100) ? 100 : (right < -100 ? -100 : right);

		setMotorSpeed(motorLinks,	 left);
		setMotorSpeed(motorRechts, right);
	}
	return false;																	// noch nicht im Ziel
}




// Main Task
task main()
{
	setMotorSpeed(Dribbler, 100); // Ürsprünglicher Dribbler Speed
	initSensor(&Kompass, KompassPort);
	initSensor(&Seeker, SeekerPort);

	readSensor(&Kompass);
	ini_goal_dir = Kompass.heading;
	Kompass.offset = ini_goal_dir; // Nullpunkt auf Tor ausrichten

	goal_final = false;
	have_ball	 = false;
	dribbler_speed_ini = getMotorRPM(Dribbler); // Ursprünglicher Dribbler Speed festlegen

	while (true)
	{
		// Sensoren Auslesen
		readSensor(&Kompass);
		me_dir = Kompass.relativeHeading;

		readSensor (&Seeker);
		ball_dir = Seeker.acDirection;

		dribbler_speed = getMotorRPM(Dribbler);

		dis_left	= getUSDistance(UltLinks);
		dis_front = getUSDistance(UltFront);

		debugScreen();


		// Main
		if ((dribbler_speed < dribbler_speed_ini + toleranz) && (dribbler_speed > dribbler_speed_ini - toleranz))
		{
			have_ball = true;
			if (me_dir != ini_goal_dir && goal_final == false)
			{
				alignToHeadingStep(ini_goal_dir, true);
			}
			else if (me_dir == ini_goal_dir && goal_final == false)
			{
                               // Tangens-Rechnung an neue Feldgröße angepasst
                               if (dis_left < FIELD_WIDTH / 2)
                               {
                                       goal_dir = atan2((FIELD_WIDTH / 2) - dis_left,
                                                        FIELD_LENGTH - dis_front);
                               }
                               else
                               {
                                       goal_dir = -atan2(dis_left - (FIELD_WIDTH / 2),
                                                         FIELD_LENGTH - dis_front);
                               }
                               goal_final = true;
			}
			else if (goal_final == true)
			{
				if (me_dir == goal_dir)
				{

					setMotorSpeed(motorLinks, motor_speed);
					setMotorSpeed(motorRechts, motor_speed);

				}
				else
				{
					alignToHeadingStep(goal_dir, false);
				}
			}

		}
		else
		{
			status = 1; // suche Ball
			goal_final = false;
			have_ball = false;

			// Ball suchen
			if (ball_dir == 5)
			{
				setMotorSpeed(motorLinks, motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
			else if (ball_dir < 5) // Ball rechts
			{
				setMotorSpeed(motorLinks, motor_speed / 2);
				setMotorSpeed(motorRechts, motor_speed * 2);
			}
			else if (ball_dir > 5) // Ball links
			{
				setMotorSpeed(motorLinks, motor_speed * 2);
				setMotorSpeed(motorRechts, motor_speed / 2);
			}
			else
			{
				setMotorSpeed(motorLinks, -motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
		}
		wait1Msec (50);
	}

}