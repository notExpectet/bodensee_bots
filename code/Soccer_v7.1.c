#pragma config(Sensor, S1,     Ult1,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     Ult2,           sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          motorLinks,    tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Dribbler,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRechts,   tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is intellectual property of Bodensee Bots j.r.t. and is not allowed to be used for commercial purposes.
// The authors are not responsible for any damage caused by the use of this code.
//This code may be used for educational Purposes
// Code created by:  Peer Siems, 2025 / Marlon Jost, 2025
// Soccerversion 7.1 STABLE RELEASE

#include "hitechnic-compass.h"
#include "hitechnic-irseeker-v2.h"

#define SeekerPort S3
#define KompassPort S4

tHTMC Kompass;
tHTIRS2 Seeker;

int status = 0;
// STATUS: 0 = Ball suchen, 1 = habe Ball, 2 = Tor anfahren

int dribbler_speed = 0;
int dribbler_speed_ini = 0;

int DribblerS;
int DribblerSpeedBall
long TorRichtung;
long Abweichung;
long BallRichtung;

float TorFinalRichtung;
float Ultlinks;
float Ulthinten;

bool BallDa = false;
bool TorOK = false;



void TorFinal()
{

	if ((Abweichung >= TorFinalRichtung-5) && (Abweichung <= TorFinalRichtung+5))
	{
		setMotorSpeed(motorLinks, 20);
		setMotorSpeed(motorRechts, 20);
		wait1Msec(5000);
		TorOK = true;
	}


	if (Abweichung < TorFinalRichtung - 5)
	{
		setMotorSpeed(motorLinks, -10);
		setMotorSpeed(motorRechts, 10);
		TorOK = false;
	}

	if (Abweichung > TorFinalRichtung + 5)
	{
		setMotorSpeed(motorLinks, 10);
		setMotorSpeed(motorRechts, -10);
		TorOK = false;
	}

}

void Tor()
{
	if ((Abweichung > -5) && (Abweichung < 2))
	{
		setMotorSpeed(motorLinks, 5);
		setMotorSpeed(motorRechts, -5);
	}

	else if ((Abweichung < -5) && (Abweichung > -180))
	{
		setMotorSpeed(motorLinks, 5);
		setMotorSpeed(motorRechts, -5);
	}

	else if ((Abweichung > 5) && (Abweichung < 180)) //hi
	{
		setMotorSpeed(motorLinks, -5);
		setMotorSpeed(motorRechts, 5);
	}

	else if ((Abweichung < 3) && (Abweichung > -3))
	{
		TorOK = true;
		setMotorSpeed(motorLinks, 0);
		setMotorSpeed(motorRechts,0);

    // jetzt k?nnen korrekt US Werte gemessen werden
		Ulthinten = getUSDistance (Ult2);
		Ultlinks = getUSDistance (Ult1);
	}
}

task main();
{
	setMotorSpeed(Dribbler, 100);
	setMotorSpeed (motorLinks, 40);
	setMotorSpeed (motorRechts, 40);
	wait1Msec(800);
	DribblerS = getMotorRPM(Dribbler);
	DribblerSpeedBall = (DribblerS*0.95);
	// Senorinitialisierung
	initSensor (&Kompass, KompassPort);
	readSensor (&Kompass);
	TorRichtung = Kompass.heading;
	Kompass.offset = TorRichtung;

	initSensor (&Seeker, SeekerPort);

	// dribbler_speed_ini = getMotorRPM(Dribbler);

	clearTimer (timer1);

	while (true)
	{
		//Sensorwerte auslesen
		readSensor (&Kompass);
		Abweichung = Kompass.relativeHeading;



		readSensor (&Seeker);
		BallRichtung = Seeker.acDirection;

		DribblerS = getMotorRPM(Dribbler);



		Ulthinten = getUSDistance(Ult1);
		Ultlinks = getUSDistance(Ult2);
		//Sensorwerte anzeigen
		eraseDisplay ();
		displayBigTextLine (0, "Abweich:%d", Abweichung);
		displayBigTextLine (2, "Ball:%d Start:%d", BallRichtung, TorRichtung);
		displayBigTextLine (4, "US: %d %d ", Ultlinks, Ulthinten);
		displayBigTextLine (6, "Dribbler :%d", DribblerS);
		if ( BallDa == false) displayBigTextLine (10, "Ballsuche    ");
		if ((BallDa == true) && (TorOK == false)) displayBigTextLine (10, "Pos. best.   ");
		if ((BallDa == true) && (TorOK == true )) displayBigTextLine (10, "fahre zum Tor");
		displayBigTextLine (12, "Tor :%d", TorFinalRichtung);


		if ((dribbler_speed < DribblerSpeedBall) && (dribbler_speed > 150))
		{
			status = 1; // habe Ball
		}
		else
		{
			status = 0; // Ball suchen
		}



		if ((DribblerS <= DribblerSpeedBall) && (DribblerS > 150))
		{
			BallDa = true;
		}
		else
		{
			BallDa = false;
			TorOK = false;
		}

		//Strategie
		if ((BallDa == true) && (TorOK == false))
		{
			Tor();
		}

		if ((BallDa == true) && (TorOK == true))
		{
    // Berechne Spielfeldposition basierend auf US-Sensoren
    float roboX = 100.0 - UltLinks;     // Position von links
    float roboY = 170.0 - UltHinten;     // Position von unten

    // Richtung zum Tor (Mitte unten)
    float dx = 50.0 - roboX;
    float dy = 0.0 - roboY;

    // Winkel zur Torwand berechnen in Grad
    TorFinalRichtung = atan2(dx, dy) * 180.0 / PI;

    // Optional: Umwandlung in Bereich -180 bis 180 Grad
    if (TorFinalRichtung > 180) TorFinalRichtung -= 360;
    if (TorFinalRichtung < -180) TorFinalRichtung += 360;

    // Jetzt dreht sich der Roboter dahin
    TorFinal();
		}


		if (BallDa == false)
		{
			//Ball suchen
			if ((BallRichtung == 5) )   //|| (BallRichtung == 4) || (BallRichtung == 6)) // Ball vorne
			{
				setMotorSpeed (motorLinks, 23);
				setMotorSpeed (motorRechts, 23);
			}
			if (BallRichtung == 4) // Ball rechts
			{
				setMotorSpeed (motorLinks, -10);
				setMotorSpeed (motorRechts, 10);
			}
			if (BallRichtung == 6) // Ball links
			{
				setMotorSpeed (motorLinks, 10);
				setMotorSpeed (motorRechts, -10);
			}
			if (BallRichtung > 6)
			{
				setMotorSpeed (motorLinks, 17);
				setMotorSpeed (motorRechts, -17);
			}
			if (BallRichtung < 4)
			{
				setMotorSpeed (motorLinks, -17);
				setMotorSpeed (motorRechts, 17);
			}
		}

		// mit Motorwerten fahren
		wait1Msec (50);
	}

}
