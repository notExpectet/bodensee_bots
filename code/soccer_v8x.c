#pragma config(Sensor, S1,     UltLinks,       sensorEV3_Ultrasonic) // linker Ultraschallsensor
#pragma config(Sensor, S2,     UltRechts,      sensorEV3_Ultrasonic) // rechter Ultraschallsensor
#pragma config(Motor,  motorA,          motorLinks,    tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Dribbler,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRechts,   tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*	
	This code is intellectual property of Bodensee Bots j.r.t. and is not allowed to be used for commercial purposes.
	The authors are not responsible for any damage caused by the use of this code.
	Code created by:  Peer Siems, 2025 / Marlon Jost, 2025
	Soccerversion 8x (under construction) BETA RELEASE
*/

#include "hitechnic-compass.h"
#include "hitechnic-irseeker-v2.h"

#define SeekerPort S3
#define KompassPort S4

tHTMC Kompass;
tHTIRS2 Seeker;

int status = 0;
// Status: 0 = idle, 1 = suche ball, 2 = habe Ball

// Variablen definieren
int dribbler_speed_ini; // Ursprüngliche Dribbler Geschwindigkeit
int dribbler_speed; // Dribbler Geschwindigkeit
int me_dir; // Roboter Richtung
int ball_dir; // Ball Richtung
int dir_diff;
int ini_goal_dir; // Torwand Richtung
int toleranz = 10;
int motor_speed = 25;
int turn_speed = 0;
bool goal_final;
bool have_ball;
float goal_dir; // Tor Richtung
float dis_right; // Ultraschall Entfernung rechts
float dis_left;  // Ultraschall Entfernung links



void debugScreen()
{
eraseDisplay();
displayBigTextLine(0, "Dir:%3d", me_dir);
displayBigTextLine(2, "Ball:%3d", ball_dir);
displayBigTextLine(4, "UL:%3.0f UR:%3.0f", dis_left, dis_right);
displayBigTextLine(6, "Goal:%3.0f", goal_dir);
displayBigTextLine(8, "Status:%d", status);
}





//---------------------------------------------------------------------------
//  alignToHeadingStep()
//    • targetHeading : gewünschter Winkel 0-359°
//    • driveForward  : false = Drehung auf der Stelle
//                      true  = während des Drehens mit motor_speed vorwärts
//    • tol           : Winkel-Toleranz
//
//  Rückgabe: true  → Ziel erreicht (innerhalb tol)
//            false → weiter ausrichten
//
//  Die Funktion prüft KEINEN Ballbesitz – das erledigt dein Hauptcode.
//---------------------------------------------------------------------------
bool alignToHeadingStep(int targetHeading, bool driveForward = false, int tol = toleranz)
{
    const int maxTurnSpeed = 60;   // maximale Drehgeschwindigkeit
    const int minTurnSpeed = 10;   // minimale Drehgeschwindigkeit

    //------------------------ Kursregler (ein Schritt) ---------------------
    readSensor(&Kompass);
    int curr = Kompass.relativeHeading;          // 0-359°

    // kürzesten Winkelfehler −180 … +180 berechnen
    int diff = targetHeading - curr;
    if (diff > 180)  diff -= 360;
    if (diff < -180) diff += 360;

    int absDiff = abs(diff);
    if (absDiff <= tol) {                        // Ziel erreicht
        if (driveForward) {
            setMotorSpeed(motorLinks,  motor_speed);
            setMotorSpeed(motorRechts, motor_speed);
        } else {
            setMotorSpeed(motorLinks,  0);
            setMotorSpeed(motorRechts, 0);
        }
        return true;
    }

    // proportionale Drehgeschwindigkeit
    int turn = (absDiff * maxTurnSpeed) / 180;
    if (turn < minTurnSpeed) turn = minTurnSpeed;
    if (turn > maxTurnSpeed) turn = maxTurnSpeed;

    if (!driveForward) {
        // Rotation auf der Stelle
        setMotorSpeed(motorLinks,  (diff > 0) ?  turn : -turn);
        setMotorSpeed(motorRechts, (diff > 0) ? -turn :  turn);
    } else {
        // Vorwärts + Differenzial-Lenkung
        int left  =  motor_speed + ((diff > 0) ?  turn : -turn);
        int right =  motor_speed - ((diff > 0) ?  turn : -turn);

        // Begrenzen auf −100 … +100
        left  = (left  > 100) ? 100 : (left  < -100 ? -100 : left);
        right = (right > 100) ? 100 : (right < -100 ? -100 : right);

        setMotorSpeed(motorLinks,  left);
        setMotorSpeed(motorRechts, right);
    }
    return false;                                 // noch nicht im Ziel
}




// Main Task
task main()
{
	setMotorSpeed(Dribbler, 100); // Ürsprünglicher Dribbler Speed
	dribbler_speed_ini = getMotorRPM(Dribbler); // Ursprünglicher Dribbler Speed festlegen
	
        initSensor(&Kompass, KompassPort);
        initSensor(&Seeker, SeekerPort);

        readSensor(&Kompass);
        ini_goal_dir = Kompass.heading;
        Kompass.offset = ini_goal_dir; // Nullpunkt auf Tor ausrichten

        goal_final = false;
        have_ball  = false;

	while (true)
	{
		// Sensoren Auslesen
                readSensor(&Kompass);
                me_dir = Kompass.relativeHeading;

                readSensor (&Seeker);
                ball_dir = Seeker.acDirection;

		dribbler_speed = getMotorRPM(Dribbler);

            dis_left  = getUSDistance(UltLinks);
            dis_right = getUSDistance(UltRechts);

            debugScreen();


		// Main
		if ((dribbler_speed < dribbler_speed_ini + toleranz) && (dribbler_speed > dribbler_speed_ini - toleranz))
		{
			have_ball = true;
			if (me_dir != ini_goal_dir && goal_final == false)
			{
				alignToHeadingStep(ini_goal_dir, true);
			}
            else if (me_dir == ini_goal_dir && goal_final == false)
            {
            // Peers Tangens Rechnung
                if (dis_left < 50)
                {
                    goal_dir = atan2(50 - dis_left, 170 - dis_right);
                }
                else
                {
                    goal_dir = -atan2(dis_left - 50, 170 - dis_right);
                }
                goal_final = true;
            }
			else if (goal_final == true)
			{
				if (me_dir == goal_dir)
				{
			
					setMotorSpeed(motorLinks, motor_speed);
					setMotorSpeed(motorRechts, motor_speed);

				}
				else
				{
					alignToHeadingStep(goal_dir, false);
                }
            }

		}
		else
		{
			status = 1; // suche Ball
			goal_final = false;
			have_ball = false;

			// Ball suchen
			if (ball_dir == 5)
			{
				setMotorSpeed(motorLinks, motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
			else if (ball_dir < 5) // Ball rechts
			{
				setMotorSpeed(motorLinks, motor_speed / 2);
				setMotorSpeed(motorRechts, motor_speed * 2);
			}
			else if (ball_dir > 5) // Ball links
			{
				setMotorSpeed(motorLinks, motor_speed * 2);
				setMotorSpeed(motorRechts, motor_speed / 2);
			}
			else
			{
				setMotorSpeed(motorLinks, -motor_speed);
				setMotorSpeed(motorRechts, motor_speed);
			}
		}
		wait1Msec (50);
	}

}

